{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>MLCFlow: Simplifying MLPerf Automations</p> <p> </p> <p> </p> <p>MLCFlow is a versatile CLI and Python interface developed by MLCommons in collaboration with a dedicated team of volunteers (see Contributors). It serves as a streamlined replacement for the CMind tool, designed to drive the automation workflows of MLPerf benchmarks more efficiently. </p> <p>The concept behind CMind originated from Grigori Fursin, while the MLPerf Automations project was created by Grigori Fursin and Arjun Suresh, whose collective contributions laid the foundation for modernizing MLPerf benchmarking tools.</p> <p>On February 9, 2025, MLCFlow is releasing its first stable version, 1.0.0. This milestone was led by Arjun Suresh and Anandhu Sooraj, with support from the MLCFlow community.</p>"},{"location":"#key-features","title":"Key Features","text":"<p>Building upon the core idea of CMind\u2014wrapping native scripts with Python wrappers and YAML metadata\u2014MLCFlow focuses exclusively on key automation components: Scripts, along with its complementary modules: Cache, Docker, and Experiments. This targeted design simplifies both implementation and interface, enabling a more user-friendly experience.</p>"},{"location":"#status","title":"Status","text":"<p>MLCFlow is now fully equipped for workflow development, with complete support for all previously used CM scripts in MLPerf inference automation. If you're interested in discussions, join the MLCommons Benchmark Infra Discord channel, and check out the latest progress in Issues.</p>"},{"location":"#mlc-cli-overview","title":"MLC CLI Overview","text":"<p>The MLC Command-Line Interface (CLI) enables users to perform actions on specified targets using a simple syntax:</p> <pre><code>mlc &lt;action&gt; &lt;target&gt; [options]\n</code></pre>"},{"location":"#key-components","title":"Key Components:","text":"<ul> <li><code>&lt;action&gt;</code>: The operation to be performed.</li> <li><code>&lt;target&gt;</code>: The object on which the action is executed.</li> <li><code>[options]</code>: Additional parameters passed to the action.</li> </ul>"},{"location":"#supported-targets-and-actions","title":"Supported Targets and Actions","text":""},{"location":"#1-repo","title":"1. Repo","text":"<ul> <li>Actions related to repositories, such as cloning or updating.</li> </ul>"},{"location":"#2-script","title":"2. Script","text":"<ul> <li>Manage or execute automation scripts.</li> </ul>"},{"location":"#3-cache","title":"3. Cache","text":"<ul> <li>Handle cached data, including cleanup or inspection.</li> </ul> <p>Each target has its own set of specific actions to tailor automation workflows as specified below.</p> Target Action script run, find/search, rm, mv, cp, add, test, docker, show cache find/search, rm, show repo pull, search, rm, list, find/search , add"},{"location":"#cm-compatibility-layer","title":"CM compatibility layer","text":"<p>MLC started with a compatibility layer where by it supported MLCommons CM automations - Script, Cache and Experiment. Now, MLCFLow has just the Script Automation which is an extension of the Script Automation from CM but with a cleaner integration of Cache Automation and Docker and Test extensions. The old CM scripts are now updated with the latest MLCFlow scripts in the MLPerf Automations repository. </p>"},{"location":"#architectural-diagram","title":"Architectural Diagram","text":"<pre><code>classDiagram\n    class Action {\n        +access(options)\n        +find_target_folder(target)\n        +load_repos_and_meta()\n        +load_repos()\n        +conflicting_repo(repo_meta)\n        +register_repo(repo_meta)\n        +unregister_repo(repo_path)\n        +add(i)\n        +rm(i)\n        +save_new_meta(i, item_id, item_name, target_name, item_path, repo)\n        +update(i)\n        +is_uid(name)\n        +cp(run_args)\n        +copy_item(source_path, destination_path)\n        +search(i)\n    }\n    class RepoAction {\n        +find(run_args)\n        +github_url_to_user_repo_format(url)\n        +pull_repo(repo_url, branch, checkout)\n        +pull(run_args)\n        +list(run_args)\n        +rm(run_args)\n    }\n    class ScriptAction {\n        +search(i)\n        +rm(i)\n        +dynamic_import_module(script_path)\n        +call_script_module_function(function_name, run_args)\n        +docker(run_args)\n        +run(run_args)\n        +test(run_args)\n        +list(args)\n    }\n    class CacheAction {\n        +search(i)\n        +find(i)\n        +rm(i)\n        +show(run_args)\n        +list(args)\n    }\n    class ExperimentAction {\n        +show(args)\n        +list(args)\n    }\n    class CfgAction {\n        +load(args)\n    }\n    class Index {\n        +add(meta, folder_type, path, repo)\n        +get_index(folder_type, uid)\n        +update(meta, folder_type, path, repo)\n        +rm(meta, folder_type, path)\n        +build_index()\n    }\n    class Item {\n        +meta\n        +path\n        +repo\n        +_load_meta()\n    }\n    class Repo {\n        +path\n        +meta\n        +_load_meta()\n    }\n    class Automation {\n        +action_object\n        +automation_type\n        +meta\n        +path\n        +_load_meta()\n        +search(i)\n    }\n\n    Action &lt;|-- RepoAction\n    Action &lt;|-- ScriptAction\n    Action &lt;|-- CacheAction\n    Action &lt;|-- ExperimentAction\n    Action &lt;|-- CfgAction\n    RepoAction o-- Repo\n    ScriptAction o-- Automation\n    CacheAction o-- Index\n    ExperimentAction o-- Index\n    CfgAction o-- Index\n    Index o-- Repo\n    Index o-- Item\n    Item o-- Repo\n    Automation o-- Action</code></pre>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#dependencies","title":"Dependencies","text":"<p>MLCFlow needs <code>python&gt;=3.7</code>, <code>python3-pip</code>, <code>python3-venv</code> and <code>git</code> installed on your system.</p> UbuntuRedHatArchmacOSWindows <pre><code>sudo apt-get install -y python3-dev python3-venv python3-pip git wget sudo unzip\n</code></pre> <pre><code>sudo dnf install -y python3-dev python3-pip git wget sudo unzip binutils\n</code></pre> <pre><code>sudo pacman -Sy python python-pip git wget sudo binutils\n</code></pre> <pre><code>brew install python git wget binutils\n</code></pre> <p>TBD</p>"},{"location":"install/#activate-a-virtual-env-for-mlcflow-optional","title":"Activate a Virtual ENV for MLCFlow (Optional)","text":"<p>This step is not mandatory. But the latest <code>pip</code> install requires this or else will need the <code>--break-system-packages</code> flag while installing.</p> <pre><code>python3 -m venv mlcflow\nsource mlcflow/bin/activate\n</code></pre>"},{"location":"install/#install-mlcflow","title":"Install MLCFLow","text":"<p>If you are not using virtual ENV for installation, the latest <code>pip</code> install requires the <code>--break-system-packages</code> flag while installing.</p> <pre><code>   pip install mlcflow\n</code></pre> <p>[!IMPORTANT] If you want to pull the latest changes (recommended), please do <code>mlc pull repo</code> after the installation.</p> <p>Now, you are ready to use the <code>mlc</code> commands. Currently, <code>mlc</code> is being used to automate the benchmark runs for:</p> <ul> <li>MLPerf Inference</li> </ul>"},{"location":"targets/cache/","title":"Cache","text":"<p>Currently, the following actions are supported for cache:</p>"},{"location":"targets/cache/#find","title":"Find","text":"<p><code>find</code> action is used to list the path of the cache generated while running scripts through MLC.</p> <p>Syntax</p> <pre><code>mlc find cache --tags=&lt;list_of_tags_used_while_running_script&gt;\n</code></pre> <p>Examples of <code>find</code> action for <code>cache</code> target could be found inside the GitHub action workflow here.</p>"},{"location":"targets/cache/#show","title":"Show","text":"<p><code>show</code> action is used to list the path and meta data of the cache generated while running scripts through MLC.</p> <p>Syntax</p> <pre><code>mlc show cache --tags=&lt;list_of_tags_used_while_running_script&gt;\n</code></pre> <p>Examples of <code>show</code> action for <code>cache</code> target could be found inside the GitHub action workflow here.</p>"},{"location":"targets/cache/#rm","title":"Rm","text":"<p><code>rm</code> action is used to remove one/more caches generated while running scripts through MLC.</p> <p>Syntax</p> <pre><code>mlc rm cache --tags=&lt;list_of_tags_used_while_running_script&gt;\n</code></pre> <p>A user  could delete the entire generated caches through the following command:</p> <pre><code>mlc rm cache\n</code></pre> <p><code>-f</code> could be used to force remove caches. Without <code>-f</code>, user would be prompted for confirmation to delete a cache.</p> <p>Examples of <code>rm</code> action for <code>cache</code> target could be found inside the GitHub action workflow here.</p>"},{"location":"targets/repo/","title":"Repo","text":"<p>Currently, the following actions are supported for repos:</p>"},{"location":"targets/repo/#add","title":"Add","text":"<p><code>add</code> action is used to create a new MLC repo and register in MLCFlow. The newly created repo folder would be present inside the <code>repos</code> folder present inside the parent <code>MLC</code> folder.</p> <p>Syntax</p> <pre><code>mlc add repo &lt;repo_name/github_link&gt;\n</code></pre> <p>Examples of <code>add</code> action for <code>repo</code> target could be found inside the GitHub action workflow here.</p>"},{"location":"targets/repo/#find","title":"Find","text":"<p><code>find</code> action is used to get the path of a particular repository registered in MLCFlow. </p> <p>Syntax</p> <pre><code>mlc find repo &lt;repo_owner@repo_name&gt;\n</code></pre> <p>OR</p> <pre><code>mlc find repo &lt;repo_url&gt;\n</code></pre> <p>OR</p> <pre><code>mlc find repo &lt;repo_uid&gt;\n</code></pre> <p>OR</p> <pre><code>mlc find repo &lt;repo_alias&gt;\n</code></pre> <p>OR</p> <pre><code>mlc find repo &lt;repo_alias&gt;,&lt;repo_uid&gt;\n</code></pre> <p>Examples of <code>find</code> action for <code>repo</code> target could be found inside the GitHub action workflow here.</p>"},{"location":"targets/repo/#pull","title":"Pull","text":"<p><code>pull</code> action is used to clone a MLC repo and register in MLC.</p> <p>Syntax</p> <pre><code>mlc pull repo &lt;repo_owner&gt;@&lt;repo_name&gt;\n</code></pre> <p>OR</p> <pre><code>mlc pull repo &lt;repo_urll&gt;\n</code></pre> <p><code>--checkout</code> could be added if an user needs to checkout to a specific branch after cloning.</p> <p>Examples of <code>pull</code> action for <code>repo</code> target could be found inside the GitHub action workflow here.</p>"},{"location":"targets/repo/#list","title":"List","text":"<p><code>list</code> action is used to list the alias and path of the MLC repos registered in MLC.</p> <p>Syntax</p> <p><pre><code>mlc list repo\n</code></pre> Example of <code>list</code> action for <code>repo</code> target could be found inside the GitHub action workflow here.</p>"},{"location":"targets/repo/#rm-remove","title":"Rm (Remove)","text":"<p><code>rm</code> action is used to remove the specified repo registered in MLC.</p> <p>Syntax</p> <p><pre><code>mlc rm repo &lt;repo_owner&gt;@&lt;repo_name&gt;\n</code></pre> Example of <code>rm</code> action for <code>repo</code> target could be found inside the GitHub action workflow here.</p>"},{"location":"targets/script/","title":"Script","text":"<p>Currently, the following actions are supported for script:</p>"},{"location":"targets/script/#find","title":"Find","text":"<p><code>find</code> action is used to list the path of partiicular scripts present in MLC repos registered in MLC.</p> <p>Syntax</p> <pre><code>mlc find script --tags=&lt;list_of_tags_matching_to_particular_script&gt;\n</code></pre> <p>OR</p> <pre><code>mlc find script &lt;script_alias&gt;\n</code></pre> <p>OR</p> <pre><code>mlc find script &lt;script_uid&gt;\n</code></pre> <p>OR</p> <pre><code>mlc find script &lt;script_alias&gt;,&lt;script_uid&gt;\n</code></pre> <p>Examples of <code>find</code> action for <code>script</code> target could be found inside the GitHub action workflow here.</p>"},{"location":"targets/script/#show","title":"Show","text":"<p><code>show</code> action is used to list the path and meta data of partiicular scripts present in MLC repos registered in MLC.</p> <p>Syntax</p> <pre><code>mlc show script --tags=&lt;list_of_tags_matching_to_particular_script&gt;\n</code></pre> <p>OR</p> <pre><code>mlc show script &lt;script_alias&gt;\n</code></pre> <p>OR</p> <pre><code>mlc show script &lt;script_uid&gt;\n</code></pre> <p>OR</p> <pre><code>mlc show script &lt;script_alias&gt;,&lt;script_uid&gt;\n</code></pre> <p>Examples of <code>show</code> action for <code>script</code> target could be found inside the GitHub action workflow here.</p>"},{"location":"targets/script/#rm","title":"Rm","text":"<p><code>rm</code> action is used to remove one/more scripts present in repos which are registered in MLC.</p> <p>Syntax</p> <pre><code>mlc rm script --tags=&lt;list_of_tags_matching_to_particular_script&gt;\n</code></pre> <p>OR</p> <pre><code>mlc rm script &lt;script_alias&gt;\n</code></pre> <p>OR</p> <pre><code>mlc rm script &lt;script_uid&gt;\n</code></pre> <p><code>-f</code> could be used to force remove scripts. Without <code>-f</code>, user would be prompted for confirmation to delete a script.</p> <p>Examples of <code>rm</code> action for <code>script</code> target could be found inside the GitHub action workflow here.</p>"},{"location":"targets/script/#add","title":"Add","text":"<p><code>add</code> script is used to add a new script to any of the registered MLC repos.</p> <p>Syntax</p> <pre><code>mlc add script &lt;registered_mlc_repo_name&gt;:&lt;new_script_name&gt; --tags=&lt;set_of_tags&gt; --template=&lt;set_of_tags&gt;\n</code></pre> <ul> <li><code>--tags</code> contains set of tags to identify the newly created script.</li> <li><code>--template</code> contains set of tags of the template script from which we are creating the new script. If not specified, default template would be considered.</li> <li><code>registered_mlc_repo_name</code> is of the format <code>repo_owner</code>@<code>repo_name</code>.</li> </ul> <p>Examples of <code>add</code> action for <code>script</code> target could be found inside the GitHub action workflow here.</p>"},{"location":"targets/script/#mv","title":"Mv","text":"<p><code>mv</code> script is used to move a script from source repo to destination repo.</p> <p>Syntax</p> <pre><code>mlc mv script &lt;registered_mlc_source_repo_name&gt;:&lt;source_script_name&gt; &lt;registered_mlc_target_repo_name&gt;:&lt;source_script_name&gt; \n</code></pre> <ul> <li><code>registered_mlc_source/target_repo_name</code> is of the format <code>repo_owner</code>@<code>repo_name</code>.</li> </ul> <p>Examples of <code>mv</code> action for <code>script</code> target could be found inside the GitHub action workflow here.</p>"},{"location":"targets/script/#cp","title":"Cp","text":"<p><code>cp</code> script is used to copy a script from source repo to destination repo.</p> <p>Syntax</p> <pre><code>mlc cp script &lt;registered_mlc_source_repo_name&gt;:&lt;source_script_name&gt; &lt;registered_mlc_target_repo_name&gt;:&lt;source_script_name&gt; \n</code></pre> <ul> <li><code>registered_mlc_source/target_repo_name</code> is of the format <code>repo_owner</code>@<code>repo_name</code>.</li> </ul> <p>Examples of <code>cp</code> action for <code>script</code> target could be found inside the GitHub action workflow here.</p>"},{"location":"targets/script/#run","title":"Run","text":"<p><code>run</code> script is used to run scripts from any of the repos registered in MLC.</p> <p>Syntax</p> <pre><code>mlc run script --tags=&lt;list_of_tags_matching_to_particular_script&gt; &lt;input_flags&gt;\n</code></pre> <p>OR</p> <pre><code>mlcr &lt;list_of_tags_matching_to_particular_script&gt; &lt;input_flags&gt;\n</code></pre> <ul> <li><code>input_flags</code> are the additional input that could be given to a particular script. They are specified in the format <code>--&lt;name_of_input_flag&gt;=&lt;value&gt;</code>. Some of the examples could be found in run commands from inference documentation here.</li> </ul> <p>Examples of <code>run</code> action for <code>script</code> target could be found inside the GitHub action workflow here.</p>"},{"location":"targets/script/#docker","title":"Docker","text":"<p><code>docker</code> script is used to run scripts inside a container environment.</p> <p>Syntax</p> <pre><code>mlc docker script --tags=&lt;list_of_tags_matching_to_particular_script&gt; &lt;input_flags&gt;\n</code></pre> <ul> <li><code>input_flags</code> are the additional input that could be given to a particular script. They are specified in the format <code>--&lt;name_of_input_flag&gt;=&lt;value&gt;</code>. Some of the examples could be found in run commands from inference documentation here.</li> </ul>"},{"location":"targets/script/#test","title":"Test","text":"<p><code>test</code> script is used to test run scripts. Note that <code>test</code> action could only be performed for scripts where <code>tests</code> section is configured in <code>meta.yaml</code></p> <p>Syntax</p> <pre><code>mlc test script --tags=&lt;list_of_tags_matching_to_particular_script&gt;\n</code></pre> <ul> <li>Please click here to find the example script where the tests are being defined.</li> </ul>"},{"location":"targets/script/script-flow/","title":"MLC \"script\" execution flow","text":""},{"location":"targets/script/script-flow/#understanding-mlc-scripts","title":"Understanding MLC scripts","text":"<ul> <li>An MLC script is identified by a set of tags and by an unique ID. </li> <li>Further each MLC script can have multiple variations and they are identified by variation tags which are treated in the same way as tags and identified by a <code>_</code> prefix.</li> </ul>"},{"location":"targets/script/script-flow/#mlc-script-execution-flow_1","title":"MLC script execution flow","text":"<pre><code>graph TD\n    MLC --&gt;|env = incoming env + env_from_meta| B[Script]\n    B --&gt;|env - local_env_keys| C[List of Dependencies]\n    C --&gt; D[Preprocess]\n    D --&gt;|env - local_env_keys| E[Prehook dependencies]\n    E --&gt;F[Run script]\n    F --&gt;|env - clean_env_keys_post_deps| G[Posthook dependencies]\n    G --&gt; H[Postprocess]\n    H --&gt;|env - clean_env_keys_post_deps| I[Post dependencies]\n    I --&gt;|\"env(new_env_keys)\"| J[Script return]</code></pre> <ul> <li>When an MLC script is invoked (either by tags or by unique ID), its <code>meta.yaml</code> is processed first which will check for any <code>deps</code> script and if there are, then they are executed in order.</li> <li>Once all the <code>deps</code> scripts are executed, <code>customize.py</code> file is checked and if existing <code>preprocess</code> function inside it is executed if present. </li> <li>Then any <code>prehook_deps</code>  scripts mentioned in <code>meta.yaml</code> are executed similar to <code>deps</code></li> <li>After this, keys in <code>env</code> dictionary is exported as <code>ENV</code> variables and <code>run</code> file if exists is executed.</li> <li>Once run file execution is done, any <code>posthook_deps</code> scripts mentioned in <code>meta.yaml</code> are executed similar to <code>deps</code></li> <li>Then <code>postprocess</code> function inside customize.py is executed if present.</li> <li>After this stage any <code>post_deps</code> scripts mentioned in <code>meta.yaml</code> is executed.</li> </ul> <p>If a script is already cached, then the <code>preprocess</code>, <code>run file</code> and <code>postprocess</code> executions won't happen and only the dependencies marked as <code>dynamic</code> will be executed from <code>deps</code>, <code>prehook_deps</code>, <code>posthook_deps</code> and <code>postdeps</code>.</p>"},{"location":"targets/script/script-flow/#input-flags","title":"Input flags","text":"<p>When we run an MLC script we can also pass inputs to it and any input added in <code>input_mapping</code> dictionary inside <code>meta.yaml</code> gets converted to the corresponding <code>ENV</code> variable.</p>"},{"location":"targets/script/script-flow/#conditional-execution-of-any-deps-post_deps","title":"Conditional execution of any <code>deps</code>, <code>post_deps</code>","text":"<p>We can use <code>skip_if_env</code> dictionary inside any <code>deps</code>, <code>prehook_deps</code>, <code>posthook_deps</code> or <code>post_deps</code> to make its execution conditional</p>"},{"location":"targets/script/script-flow/#versions","title":"Versions","text":"<p>We can specify any specific version of a script using <code>version</code>. <code>version_max</code> and <code>version_min</code> are also possible options. </p> <ul> <li> <p>When <code>version_min</code> is given, any version above this if present in the cache or detected in the system can be chosen. If nothing is detected <code>default_version</code> if present and if above <code>version_min</code> will be used for installation. Otherwise <code>version_min</code> will be used as <code>version</code>.</p> </li> <li> <p>When <code>version_max</code> is given, any version below this if present in the cache or detected in the system can be chosen. If nothing is detected <code>default_version</code> if present and if below <code>version_max</code> will be used for installation. Otherwise <code>version_max_usable</code> (additional needed input for <code>version_max</code>) will be used as <code>version</code>.</p> </li> </ul>"},{"location":"targets/script/script-flow/#variations","title":"Variations","text":"<ul> <li>Variations are used to customize MLC script and each unique combination of variations uses a unique cache entry. Each variation can turn on <code>env</code> keys also any other meta including dependencies specific to it. Variations are turned on like tags but with a <code>_</code> prefix. For example, if a script is having tags <code>\"get,myscript\"</code>, to call the variation <code>\"test\"</code> inside it, we have to use tags <code>\"get,myscript,_test\"</code>. </li> </ul>"},{"location":"targets/script/script-flow/#variation-groups","title":"Variation groups","text":"<p><code>group</code> is a key to map variations into a group and at any time only one variation from a group can be used in the variation tags. For example, both <code>cpu</code> and <code>cuda</code> can be two variations under the <code>device</code> group, but user can at any time use either <code>cpu</code> or <code>cuda</code> as variation tags but not both.</p>"},{"location":"targets/script/script-flow/#dynamic-variations","title":"Dynamic variations","text":"<p>Sometimes it is difficult to add all variations needed for a script like say <code>batch_size</code> which can take many different values. To handle this case, we support dynamic variations using '#' where '#' can be dynamically replaced by any string. For example, <code>\"_batch_size.8\"</code> can be used as a tag to turn on the dynamic variation <code>\"_batch_size.#\"</code>.</p>"},{"location":"targets/script/script-flow/#env-flow-during-mlc-script-execution","title":"ENV flow during MLC script execution","text":"<ul> <li>During a given script execution incoming <code>env</code> dictionary is saved <code>(saved_env)</code> and all the updates happens on a copy of it.</li> <li>Once a script execution is over (which includes all the dependent script executions as well), newly created keys and any updated keys are merged with the <code>saved_env</code> provided the keys are mentioned in <code>new_env_keys</code></li> <li>Same behaviour applies to <code>state</code> dictionary.</li> </ul>"},{"location":"targets/script/script-flow/#special-env-keys","title":"Special env keys","text":"<ul> <li>Any env key with a prefix <code>MLC_TMP_*</code> and <code>MLC_GIT_*</code> are not passed by default to any dependency. These can be force passed by adding the key(s) to the <code>force_env_keys</code> list of the concerned dependency. </li> <li>Similarly we can avoid any env key from being passed to a given dependency by adding the prefix of the key in the <code>clean_env_keys</code> list of the concerned dependency.</li> <li><code>--input</code> is automatically converted to <code>MLC_INPUT</code> env key</li> <li><code>version</code> is converted to <code>MLC_VERSION</code>, <code>`version_min</code> to <code>MLC_VERSION_MIN</code> and <code>version_max</code> to <code>MLC_VERSION_MAX</code></li> <li>If <code>env['MLC_GH_TOKEN']=TOKEN_VALUE</code> is set then git URLs (specified by <code>MLC_GIT_URL</code>) are changed to add this token.</li> <li>If <code>env['MLC_GIT_SSH']=yes</code>, then git URLs are changed to SSH from HTTPS.</li> </ul>"},{"location":"targets/script/script-flow/#script-meta","title":"Script Meta","text":""},{"location":"targets/script/script-flow/#special-keys-in-script-meta","title":"Special keys in script meta","text":"<ul> <li>TBD: <code>reuse_version</code>, <code>inherit_variation_tags</code>, <code>update_env_tags_from_env</code></li> </ul>"},{"location":"targets/script/script-flow/#how-cache-works","title":"How cache works?","text":"<ul> <li>If <code>cache=true</code> is set in a script meta, the result of the script execution is cached for further use. </li> <li>For a cached script, <code>env</code> and <code>state</code> updates are done using <code>new_env</code> and <code>new_state</code> dictionaries which are stored in the <code>cm-cached.json</code> file inside the cached folder.</li> <li>By using <code>--new</code> input, a new cache entry can be forced even when an old one exist. </li> <li>By default no depndencies are run for a cached entry unless <code>dynamic</code> key is set for it. </li> </ul> <p>Please see here for trying MLC scripts.</p> <p>\u00a9 2022-25 MLCommons</p>"},{"location":"targets/script/script-meta-inf/","title":"Index","text":"<p>This page provides a walkthrough of the <code>meta.yaml</code> file.</p>"},{"location":"targets/script/script-meta-inf/#keys-and-datatypes-followed","title":"Keys and Datatypes followed","text":"<ol> <li>alias: <code>string</code><ul> <li>Contains alias of the script which would be used instead of tags while runnning a script.</li> </ul> </li> <li>uid: <code>string</code><ul> <li>Unique identifier used to identify individual scripts. </li> <li>Could be used instead of tags while running a script</li> </ul> </li> <li>automation_alias: <code>string</code><ul> <li>Alias with respect to particular automation</li> </ul> </li> <li>automation_uid: <code>string</code><ul> <li>Unique identifier used to identify an automation</li> </ul> </li> <li>category: <code>string</code><ul> <li>Script category</li> </ul> </li> <li>developers: <code>list of strings</code><ul> <li>List of developers who were involved in developing the particular script</li> </ul> </li> <li>tags: <code>list of strings</code><ul> <li>List of tags which could be specified by the user to run the particular script</li> </ul> </li> <li>default_env: <code>dictionary</code> - Contains key-value pairs where values are <code>strings</code><ul> <li>Contains key-value pairs which depicts the env variable and their value which could be set as default for a particular script.</li> <li>The value of any default env would be replaced if the env variable is set anywhere in script files or is populated from the parent script to child.</li> </ul> </li> <li>env: <code>dictionary</code> - Contains key-value pairs where values are <code>strings</code><ul> <li>This key could be used to set a series of env variable and their values.</li> </ul> </li> <li>input_mapping: <code>dictionary</code> - Contains key-value pairs where values are <code>strings</code><ul> <li>This helps to map the input flags related to a particular script to the corresponding env variable</li> <li>Only the keys that are specified under <code>input_mapping</code> in <code>meta.yml</code> of a script are being mapped to env variable.</li> </ul> </li> <li>env_key_mapping: <code>dictionary</code> - Contains key-value pairs where values are <code>strings</code><ul> <li>Used to map a particular env key to another env key.</li> </ul> </li> <li>new_env_keys: <code>list of strings</code><ul> <li>Used to specify the env keys that should be passed to the parent script(if the particular script is called as a dependency of another script).</li> </ul> </li> <li>new_state_keys: <code>list of strings</code><ul> <li>Used to specify the state keys that should be passed to the parent script(if the particular script is called as a dependency of another script).</li> </ul> </li> <li>deps: <code>list of dictionaries</code> - Each dictionary can contain <code>tags</code> or other nested keys<ul> <li>List of dictionaries which specify the tags of the scripts that should be called as a dependency, env variable that should be passed, version, names, etc</li> <li>names: <code>list of strings</code><ul> <li>They are the list of strings that the user could specify for that particular dependency so that whenever user needs to explicitely modify the configuration to be passed for that particular script, they could access through this name. </li> </ul> </li> <li>enable_if_env: <code>dictionary</code> - Contains key-value pairs where values are lists of <code>strings</code><ul> <li>This key could be used to configure script such that the particular dependency should only be called if one/more env variables are enabled, or their value is set to something specific. </li> </ul> </li> <li>skip_if_env: <code>dictionary</code> - Contains key-value pairs where values are lists of <code>strings</code>.<ul> <li>This key could be used to configure script such that the particular dependency should be skipped if one/more env variables are enabled, or their value is set to something specific. </li> </ul> </li> </ul> </li> <li>prehook_deps: <code>list of dictionaries</code> - Each dictionary may contain <code>names</code> and <code>tags</code> as lists<ul> <li>List of dictionaries which specify the tags of the scripts that should be called as a prehook dependency, env variable that should be passed, version, names, etc</li> <li>To know more about the script execution flow, please see this documentation.</li> </ul> </li> <li>posthook_deps: <code>list of dictionaries</code> - Each dictionary may contain <code>tags</code> and other keys<ul> <li>List of dictionaries which specify the tags of the scripts that should be called as a posthook dependency, env variable that should be passed, version, names, etc</li> <li>To know more about the script execution flow, please see this documentation.</li> </ul> </li> <li>variation_groups_order: <code>list of strings</code></li> <li>variations: <code>dictionary</code> - Each variation is a dictionary containing keys like <code>alias</code>, <code>default_variations</code>, <code>group</code>, etc.</li> <li>group: <code>string</code></li> <li>add_deps_recursive: <code>dictionary</code> - Contains nested <code>tags</code> and other keys</li> <li>default_variations: <code>dictionary</code> - Contains key-value pairs where values are <code>strings</code></li> <li>docker: <code>dictionary</code> - Contains keys specific to Docker configurations:<ul> <li>base_image: <code>string</code></li> <li>image_name: <code>string</code></li> <li>os: <code>string</code></li> <li>os_version: <code>string</code></li> <li>deps: <code>list of dictionaries</code> - Each dictionary can include <code>tags</code> or other keys.</li> <li>env: <code>dictionary</code> - Contains key-value pairs where values are <code>strings</code></li> <li>interactive: <code>boolean</code></li> <li>extra_run_args: <code>string</code></li> <li>mounts: <code>list of strings</code> - Specifies mount paths in the format <code>\"source:destination\"</code></li> <li>pre_run_cmds: <code>list of strings</code> - Commands to run before the container starts</li> <li>docker_input_mapping: <code>dictionary</code> - Contains key-value pairs where values are strings, mapping input parameters to Docker environment variables</li> <li>use_host_user_id: <code>boolean</code></li> <li>use_host_group_id: <code>boolean</code></li> <li>skip_run_cmd: <code>string</code></li> <li>shm_size: <code>string</code></li> <li>real_run: <code>boolean</code></li> <li>all_gpus: <code>string</code></li> </ul> </li> </ol>"}]}